.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.22)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Git::PurePerl::Walker 3"
.TH Git::PurePerl::Walker 3 "2012-05-30" "perl v5.16.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Git::PurePerl::Walker \- Walk over a sequence of commits in a Git::PurePerl repo
.SH "VERSION"
.IX Header "VERSION"
version 0.002000
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use Git::PurePerl::Walker;
\&        use Git::PurePerl::Walker::Method::FirstParent;
\&
\&        my $repo = Git::PurePerl\->new( ... );
\&
\&        my $walker = Git::PurePerl::Walker\->new(
\&                repo => $repo,
\&                method => Git::PurePerl::Walker::Method::FirstParent\->new(
\&                        start => $repo\->ref_sha1(\*(Aqrefs/heads/master\*(Aq),
\&                ),
\&                on_commit => sub {
\&                        my ( $commit ) = @_;
\&                        print $commit\->sha1;
\&                },
\&        );
\&
\&        $walker\->step_all;
.Ve
.SH "CONSTRUCTOR ARGUMENTS"
.IX Header "CONSTRUCTOR ARGUMENTS"
.SS "repo"
.IX Subsection "repo"
\&\fBMandatory:\fR An instance of \f(CW\*(C`Git::PurePerl\*(C'\fR representing
the repository to work with.
.SS "method"
.IX Subsection "method"
\&\fBMandatory:\fR either a \f(CW\*(C`Str\*(C'\fR describing a Class Name Suffix, or an \f(CW\*(C`Object\*(C'\fR
that \f(CW\*(C`does\*(C'\fR
\&\f(CW\*(C`Git::PurePerl::\f(CBWalker::Role::Method\f(CW\*(C'\fR.
.PP
If its a \f(CW\*(C`Str\*(C'\fR, the \f(CW\*(C`Str\*(C'\fR will be expanded as follows:
.PP
.Vb 5
\&        \->new(
\&                ...
\&                method => \*(AqFoo\*(Aq,
\&                ...
\&        );
\&
\&        $className = \*(AqGit::PurePerl::Walker::Method::Foo\*(Aq
.Ve
.PP
And the resulting class will be loaded, and instantiated for you. ( Assuming of
course, you don't need to pass any fancy args ).
.PP
If you need fancy args, or a class outside the
\&\f(CW\*(C`Git::PurePerl::\f(CBWalker::Method::\f(CW\*(C'\fR namespace, constructing the object will
have to be your responsibility.
.PP
.Vb 5
\&        \->new(
\&                ...
\&                method => Foo::Class\->new(),
\&                ...
\&        )
.Ve
.SS "on_commit"
.IX Subsection "on_commit"
\&\fBMandatory:\fR either a \f(CW\*(C`Str\*(C'\fR that can be expanded in a way similar to that by
\&\f(CW\*(C`\f(CImethod\f(CW\*(C'\fR, a \f(CW\*(C`CodeRef\*(C'\fR, or an object that \f(CW\*(C`does\*(C'\fR \f(CW\*(C`Git::PurePerl::\f(CBWalker::Role::OnCommit\f(CW\*(C'\fR.
.PP
If passed a \f(CW\*(C`Str\*(C'\fR it will be expanded like so:
.PP
.Vb 5
\&        \->new(
\&                ...
\&                on_commit => $str,
\&                ...
\&        );
\&
\&        $class = \*(AqGit::PurePerl::Walker::OnCommit::\*(Aq . $str;
.Ve
.PP
And the resulting class loaded and instantiated.
.PP
If passed a \f(CW\*(C`CodeRef\*(C'\fR,
\&\f(CW\*(C`Git::PurePerl::\f(CBWalker::OnCommit::CallBack\f(CW\*(C'\fR will be loaded and your \f(CW\*(C`CodeRef\*(C'\fR will be passed as an argument.
.PP
.Vb 4
\&        \->new(
\&                ...
\&                on_commit => sub {
\&                        my ( $commit ) = @_;
\&
\&                },
\&                ...
\&        );
.Ve
.PP
If you need anything fancier, or requiring an unusual namespace, you'll want to
construct the object yourself.
.PP
.Vb 5
\&        \->new(
\&                ...
\&                on_commit => Foo::Package\->new()
\&                ...
\&        );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "reset"
.IX Subsection "reset"
.Vb 1
\&        $walker\->reset();
.Ve
.PP
Reset the walk routine back to the state it was before you walked.
.SS "step"
.IX Subsection "step"
Increments one step forward in the git history, and dispatches the object to the
OnCommit handlers.
.PP
If there are more possible steps to take, it will return a true value.
.PP
.Vb 3
\&        while ( $walker\->step ) {
\&                /* Code to execute if walker has more items */
\&        }
.Ve
.PP
This code is almost identical to:
.PP
.Vb 2
\&        while(1) {
\&                $walker\->on_commit\->handle( $walker\->method\->current );
\&
\&                last if not $walker\->method\->has_next;
\&
\&                $walker\->method\->next;
\&
\&                /*  Code to execute if walker has more items */
\&        }
.Ve
.SS "step_all"
.IX Subsection "step_all"
.Vb 1
\&        my $steps = $walker\->step_all;
.Ve
.PP
Mostly a convenience method to iterate until it can iterate no more, but without
you needing to wrap it in a \fIwhile()\fR block.
.PP
Returns the number of steps executed.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "repo"
.IX Subsection "repo"
.SS "method"
.IX Subsection "method"
.SS "on_commit"
.IX Subsection "on_commit"
.SH "ATTRIBUTE GENERATED METHODS"
.IX Header "ATTRIBUTE GENERATED METHODS"
.SS "repo"
.IX Subsection "repo"
.Vb 2
\&        # Getter
\&        my $repo = $walker\->repo();
.Ve
.SS "method"
.IX Subsection "method"
.Vb 2
\&        # Getter
\&        my $method_object = $walker\->method();
.Ve
.SS "on_commit"
.IX Subsection "on_commit"
.Vb 2
\&        # Getter
\&        my $on_commit_object = $walker\->on_commit();
.Ve
.SH "PRIVATE ATTRIBUTES"
.IX Header "PRIVATE ATTRIBUTES"
.SS "_method"
.IX Subsection "_method"
.SS "_on_commit"
.IX Subsection "_on_commit"
.SH "PRIVATE METHODS"
.IX Header "PRIVATE METHODS"
.SS "_build_repo"
.IX Subsection "_build_repo"
.SS "_build_method"
.IX Subsection "_build_method"
.SS "_build_on_commit"
.IX Subsection "_build_on_commit"
.SH "PRIVATE ATTRIBUTE GENERATED METHODS"
.IX Header "PRIVATE ATTRIBUTE GENERATED METHODS"
.SS "_method"
.IX Subsection "_method"
.Vb 2
\&        # Getter
\&        my $methodish = $walker\->_method();
.Ve
.SS "_on_commit"
.IX Subsection "_on_commit"
.Vb 2
\&        # Getter
\&        my $on_commitish => $walker\->_on_commit();
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Kent Fredric <kentnl@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Kent Fredric <kentnl@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
